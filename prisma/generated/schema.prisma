generator client {
  provider = "prisma-client-js"
  output   = "../prisma/generated"
}

generator dbml {
  provider              = "prisma-dbml-generator"
  includeRelationFields = "false"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl = env("DIRECT_DATABASE_URL")
}

model class_schedule {
  ClassID                 String                    @id
  TimeslotID              String
  SubjectCode             String
  RoomID                  Int?
  GradeID                 String
  IsLocked                Boolean                   @default(false)
  gradelevel              gradelevel                @relation(fields: [GradeID], references: [GradeID], onDelete: Cascade, map: "fk_class_schedule_grade")
  room                    room?                     @relation(fields: [RoomID], references: [RoomID], map: "fk_class_schedule_room")
  subject                 subject                   @relation(fields: [SubjectCode], references: [SubjectCode], onDelete: Cascade, map: "fk_class_schedule_subject")
  timeslot                timeslot                  @relation(fields: [TimeslotID], references: [TimeslotID], onDelete: Cascade, map: "fk_class_schedule_timeslot")
  teachers_responsibility teachers_responsibility[]

  @@index([GradeID], map: "class_schedule_GradeID_idx")
  @@index([RoomID], map: "class_schedule_RoomID_idx")
  @@index([SubjectCode], map: "class_schedule_SubjectCode_idx")
  @@index([TimeslotID], map: "class_schedule_TimeslotID_idx")
  // Performance indexes for conflict detection
  @@index([TimeslotID, GradeID], map: "class_schedule_timeslot_grade_idx")
  @@index([TimeslotID, RoomID], map: "class_schedule_timeslot_room_idx")
  @@index([GradeID, IsLocked], map: "class_schedule_grade_locked_idx")
}

model gradelevel {
  GradeID                 String                    @id
  Year                    Int
  Number                  Int
  class_schedule          class_schedule[]
  teachers_responsibility teachers_responsibility[]
  program                 program[]
}

model room {
  RoomID         Int              @id @default(autoincrement())
  RoomName       String           @unique
  Building       String           @default("-")
  Floor          String           @default("-")
  class_schedule class_schedule[]
}

model subject {
  SubjectCode             String                    @id
  SubjectName             String
  Credit                  subject_credit
  Category                String                    @default("-")
  ProgramID               Int?
  class_schedule          class_schedule[]
  program                 program?                  @relation(fields: [ProgramID], references: [ProgramID], map: "fk_subject_program")
  teachers_responsibility teachers_responsibility[]

  @@index([ProgramID], map: "subject_ProgramID_idx")
}

model program {
  ProgramID   Int          @id @default(autoincrement())
  ProgramName String       @unique
  Semester    semester
  subject     subject[]
  gradelevel  gradelevel[]
}

model teacher {
  TeacherID               Int                       @id @default(autoincrement())
  Prefix                  String
  Firstname               String
  Lastname                String
  Department              String                    @default("-")
  Email                   String                    @unique
  Role                    String                    @default("teacher")
  teachers_responsibility teachers_responsibility[]
}

model timeslot {
  TimeslotID     String           @id
  AcademicYear   Int
  Semester       semester
  StartTime      DateTime         @db.Time(0)
  EndTime        DateTime         @db.Time(0)
  Breaktime      breaktime
  DayOfWeek      day_of_week
  class_schedule class_schedule[]

  // Performance index for finding timeslots by term and day
  @@index([AcademicYear, Semester, DayOfWeek], map: "timeslot_term_day_idx")
}

model teachers_responsibility {
  RespID         Int              @id @default(autoincrement())
  TeacherID      Int
  GradeID        String
  SubjectCode    String
  AcademicYear   Int
  Semester       semester
  TeachHour      Int
  gradelevel     gradelevel       @relation(fields: [GradeID], references: [GradeID], onDelete: Cascade, map: "fk_teachers_responsibility_grade")
  subject        subject          @relation(fields: [SubjectCode], references: [SubjectCode], onDelete: Cascade, map: "fk_teachers_responsibility_subject")
  teacher        teacher          @relation(fields: [TeacherID], references: [TeacherID], onDelete: Cascade, map: "fk_teachers_responsibility_teacher")
  class_schedule class_schedule[]

  @@index([TeacherID], map: "teachers_responsibility_TeacherID_idx")
  @@index([GradeID], map: "teachers_responsibility_GradeID_idx")
  @@index([SubjectCode], map: "teachers_responsibility_SubjectCode_idx")
  // Performance indexes for finding teacher assignments
  @@index([TeacherID, AcademicYear, Semester], map: "teachers_responsibility_teacher_term_idx")
  @@index([GradeID, SubjectCode, AcademicYear, Semester], map: "teachers_responsibility_grade_subject_term_idx")
}

model table_config {
  ConfigID     String   @id
  AcademicYear Int
  Semester     semester
  Config       Json

  // New fields for semester status and metadata
  status             SemesterStatus @default(DRAFT)
  publishedAt        DateTime?
  isPinned           Boolean        @default(false)
  lastAccessedAt     DateTime       @default(now())
  configCompleteness Int            @default(0) // 0-100%

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([status], map: "table_config_status_idx")
  @@index([isPinned], map: "table_config_pinned_idx")
  @@index([lastAccessedAt], map: "table_config_accessed_idx")
}

enum SemesterStatus {
  DRAFT
  PUBLISHED
  LOCKED
  ARCHIVED
}

enum day_of_week {
  MON
  TUE
  WED
  THU
  FRI
  SAT
  SUN
}

enum subject_credit {
  CREDIT_05
  CREDIT_10
  CREDIT_15
  CREDIT_20
}

enum semester {
  SEMESTER_1
  SEMESTER_2
}

enum breaktime {
  BREAK_JUNIOR
  BREAK_SENIOR
  BREAK_BOTH
  NOT_BREAK
}

// ====================
// Auth.js v5 Models (Prisma Adapter)
// Required for multi-tenant authentication
// @see https://authjs.dev/getting-started/adapters/prisma
// ====================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String? // For credential-based login (hashed with bcrypt)
  role          String    @default("user") // user, teacher, admin
  accounts      Account[]
  sessions      Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}
